<?xml version="1.0" encoding="UTF-8"?>
<document>
	<properties>
		<title>Errors management</title>
		<author email="francois-xavier.bonnet@centraliens.net">Francois-Xavier Bonnet</author>
	</properties>
	<body>
		While retrieving a page or resource from a distant server, a lot of
		things can occur. ESIGate provides solutions to handle properly this
		kind of problems.
		<section name="Http errors">
			Any HTTP status code different from the following codes is considered
			as an error :
			<ul>
				<li>200 OK</li>
				<li>301 Moved permanently</li>
				<li>302 Moved temporarily</li>
				<li>304 Not modified</li>
			</ul>
		</section>
		<section name="Network errors and timeout">
			There are several kind of network problems for example :
			<ul>
				<li>DNS errors (host name cannot be resolved)</li>
				<li>Connection refused (can be a wrong port number or a firewall
					problem)</li>
				<li>Broken pipe (host closed connection unexpectedly)</li>
				<li>...</li>
			</ul>
			In addition, for performance issues, ESIGate cannot wait indefinitely
			for the target server to answer. That is the reason for the "timeout"
			configuration parameter. This parameter is used in 2 cases :
			<ul>
				<li>Connection timeout (trying to connect to the server but the
					server does not answer)</li>
				<li>Socket timeout (the connection has been established, the server
					may have started sending the response but no packet has been
					received for too much time)</li>
			</ul>
			All these problems are handled like Http errors with the following
			codes :
			<table>
				<tr>
					<th>Problem type</th>
					<th>Http status</th>
					<th>Http message</th>
				</tr>
				<tr>
					<td>Connection refused</td>
					<td>502</td>
					<td>Bad Gateway</td>
				</tr>
				<tr>
					<td>Connection pool timeout (all the http connections to current
						host are busy)</td>
					<td>504</td>
					<td>Gateway timeout</td>
				</tr>
				<tr>
					<td>Connect timeout</td>
					<td>504</td>
					<td>Gateway timeout</td>
				</tr>
				<tr>
					<td>Socket timeout</td>
					<td>504</td>
					<td>Gateway timeout</td>
				</tr>
				<tr>
					<td>Error retrieving URL (any other error)</td>
					<td>500</td>
					<td>Internal server error</td>
				</tr>
			</table>
		</section>
		<section name="Handling errors with ESIGate">
			In case of an error, there are several possible ways to handle the
			problem :
			<ul>
				<li>Display the error page from the target server in case of an HTTP error</li>
				<li>Display an error page in case of other errors (application server default error page with stacktrace or custom error page)</li>
				<li>Display a simple error message (status code + status text)</li>
				<li>Display a generic error message or just nothing</li>
			</ul>
			Depending on where we are, we cannot do anything : for example, while
			rendering a block inside a page, if a problem occurs but the response
			is already commited, we can only display a simplified message or
			generic message because rendering the complete error page may result
			in a page totally broken.
		</section>
		<section name="Cache and errors">
			According to HTTP specifications, a HTTP compliant cache system
			should never cache pages with status code other than 200 OK. In
			ESIGate, it was decided to do exactly the contrary :
			<strong>error pages are always cached.</strong>
			This behaviour is designed to avoid performance issues, when there is
			an
			error on a resource, there is no reason to continue asking for the
			same resource again and again. ESIGate will keep the response in
			cache and try a new request only when the cache entry has expired.
		</section>
	</body>
</document>